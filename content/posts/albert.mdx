---
title: "Albert: Designing a Secure-First Personal Agent"
excerpt: "Building an agentic SDK where security isn't bolted on—it's the foundation. A deep dive into trust gradients, constitutional judges, and why your agent should never hold your secrets."
publishedAt: "2026-02-22"
tags: ["ai", "security", "agents", "systems"]
author: "Anand Mohan"
published: true
---

# Albert: Designing a Secure-First Personal Agent

Most agent frameworks treat security as an afterthought. They give the LLM direct access to your filesystem, your credentials, your email. When things go wrong—and they will—the blast radius is your entire digital life.

Albert takes a different approach: assume the agent is compromised from day one. Build a system where even a fully adversarial LLM can't exfiltrate your data, modify its own rules, or escalate its privileges. This isn't paranoia—it's the only rational design when you're handing an AI the keys to your infrastructure.

This post walks through the architecture of Albert, a secure-by-default agentic SDK. We'll cover trust gradients, constitutional enforcement, execution isolation, and why the hardest problems in agent security are actually solved problems in systems design.

> **Status**: Albert is in active development at [github.com/anandmoghan/albert](https://github.com/anandmoghan/albert). This document reflects the v0.3 architecture as of February 2026. If you spot issues or have questions, reach out at [moghan.anand@gmail.com](mailto:moghan.anand@gmail.com).

## The Core Principle

Traditional agent frameworks operate on binary trust: either the agent is trusted (full access) or it's not (no access). This doesn't match reality. You want your agent to read your calendar but not delete it. You want it to draft emails but not send them without approval. You want it to run code but not access the network.

Albert's design centers on a **trust gradient**: every component has a defined trust level, and no single component is fully trusted. The blast radius of any compromise is bounded by architectural isolation, not by hoping the LLM behaves.

The trust hierarchy:

| Component | Trust Level | Holds Secrets | Can Modify Constitution |
|-----------|-------------|---------------|------------------------|
| Agent LLM (Albert) | Zero | No | No |
| Constitutional Judge | Partial (input-isolated) | No | No |
| Go Orchestrator | High (security core) | Via OS keychain only | No (read-only at runtime) |
| TypeScript SDK/UI | Zero | No | No |
| Firecracker VMs | Zero | Ephemeral scoped credentials only | No |

The agent itself—the LLM generating tool calls and responses—is assumed potentially compromised at every step. It cannot see credentials, cannot modify its own rules, and cannot influence security decisions. All security logic lives in the Go orchestrator, which the agent cannot reach.

## Architecture

Albert consists of three components, each with a defined security boundary:

### TypeScript Client

The client handles three responsibilities:

**SDK** — Tool definition interface and session management. Developers define tools (name, argument schema, implementation) and send user messages to the orchestrator. The SDK has zero knowledge of the constitution, trust tiers, or security policy. It's purely a communication layer over a Unix socket.

**Web UI** — Static React/Vite bundle served on localhost only. Handles configuration, audit log viewing, memory inspection, contacts management, job scheduling, ESCALATE approval interface, and constitution editing (manual only—the agent cannot modify it). Every request requires a session token. CORS is strict: all non-localhost origins are rejected.

**Channel aggregator** — Webhook listeners for WhatsApp, Telegram, and other messaging platforms. Forwards raw signed payloads to the orchestrator verbatim. Zero trust decisions made here. Webhook signing secrets are stored in the orchestrator—the TypeScript server never holds them.

The TypeScript server binds to localhost only and makes no security decisions. It's a dumb proxy. If it's compromised, the attacker gains nothing—no secrets, no ability to bypass security checks, no access to the orchestrator's decision logic.

### Go Orchestrator

The orchestrator is the only trusted component. It runs as a local background service accessible only via Unix socket. Every secret in the system lives exclusively in the OS keychain (macOS Keychain, Linux Secret Service). Its responsibilities:

**Unix socket server** — Separate sockets for agent communication (session token auth) and admin operations (OAuth verified). The agent socket and admin socket are isolated—compromising one doesn't grant access to the other.

**OAuth verification** — Verifies Google OAuth tokens independently on every request using cached Google public keys. The TypeScript server passes tokens through but never makes trust decisions.

**LLM proxy** — All agent LLM calls are proxied through the orchestrator. The API key is retrieved from the OS keychain at call time, held in memory only for the duration of the HTTP request, then discarded. Never cached between requests. Full reasoning trace logged to the audit trail.

**Agent loop** — LLM response parsing, tool call extraction, and result injection all happen inside the orchestrator. The SDK never sees intermediate tool calls or raw LLM responses. The agent cannot manipulate what the orchestrator sees.

**Input sanitization** — Strips control characters, bidirectional text markers, known injection patterns. Enforces field length limits. All sanitization happens before any content reaches the constitutional judge.

**Risk classification** — Deterministic Tier 0–3 classification based on tool name, arguments, and declared schema. No LLM involved. Tier 0 (pure CPU/memory, zero I/O) is eligible for the schema-less lite path. Tier 1+ requires schema validation and judge evaluation.

**Decision cache** — Hash-based cache of judge verdicts with TTL. Cache key includes tool name, normalized arguments, argument schema, and tool content hash. Cache hits skip the judge entirely—massive latency win for repeated operations.

**Constitutional judge** — Separate LLM call with a hardcoded system prompt, clean context isolated from the agent session. Receives sanitized structured input only. Output parsed as strict JSON schema; any parse failure triggers the circuit breaker. Model version is explicitly pinned—upgrades require re-validation against the constitution, not silent swaps. Judge API unavailability defaults to DENY with queued retry.

**Credential broker** — Retrieves credentials from the OS keychain, issues ephemeral scoped tokens immediately before tool execution, revokes after. The agent never holds credentials directly. Even if the agent is fully compromised, it cannot exfiltrate long-lived credentials.

**Firecracker VM lifecycle** — Manages ephemeral execution VMs (per tool call) and scheduled service VMs (email watcher, cron jobs). All VM types use the same configurable VM interface, making it straightforward to substitute alternative runtimes (gVisor, cloud-hypervisor) without changing any other component.

**Memory system** — All memory writes are validated by the judge before storage. Provenance is tracked per entry: high-trust tier (user-direct utterances only) and low-trust tier (inferred from external content). Pending actions are double-validated: at write time and at session-start read time.

**Contacts store** — Per-contact profile, interaction log (summaries only, never raw content), trust levels, pending actions. The agent can query contacts but cannot modify trust levels—only the user can via the web UI.

**Job scheduler** — Cron-based scheduler for system jobs (email watcher, VM health monitoring, memory TTL cleanup) and user-defined jobs. All scheduled jobs run inside Firecracker VMs created on schedule and torn down after completion. No VM runs permanently.

**Webhook signature verification** — Verifies channel provider signatures (WhatsApp, Telegram) independently using secrets retrieved from the OS keychain. The TypeScript server forwards payloads but doesn't verify them—only the orchestrator does.

**Append-only audit log** — Every tool call, memory write, LLM proxy call, judge verdict, and config change is recorded. The orchestrator can only append, never modify. Distinct from the forensic quarantine store (see Security Architecture Refinements).

**Forensic quarantine** — Write-only store with OS-level access control, not readable by the orchestrator at runtime. On adversarial halt events (input-correlated judge failures), the orchestrator serializes: raw input bytes, malformed judge output, failure count, channel context, session identifier. Accessible only via out-of-band tooling.

### Firecracker VM Execution

All sandboxed execution—tool calls, email watching, scheduled jobs, web scraping, browser automation—runs inside Firecracker microVMs. The VM backend is abstracted behind an interface in the orchestrator, making it straightforward to substitute alternative runtimes without changing any other component.

**Platform implementation:**

| Platform | Runtime |
|----------|---------|
| macOS (Apple Silicon) | Lima VM hosts the Firecracker runtime. All execution requests go through the orchestrator inside the Lima VM. Mac-side process has zero direct VM access. |
| Linux | Firecracker microVMs run directly via KVM. No wrapper needed. |

**VM classes:**

**Ephemeral execution VMs** — Created per tool call, torn down immediately after. Read-only rootfs, scoped writable tmpfs wiped on teardown. Used for tool execution, form filling, web scraping, browser automation.

**Scheduled service VMs** — Created by the job scheduler at the configured cron time, run their task, and torn down on completion. Used for email watching, feed monitoring, report generation, and all other scheduled jobs. No VM runs permanently—each invocation is a fresh VM from a clean base image.

**VM configuration interface:**

The orchestrator defines a VM interface contract with the following operations: `Create`, `Execute`, `CopyIn`, `CopyOut`, `Destroy`. Any runtime implementing this interface can be used as the execution backend. Configuration is set at install time via the orchestrator config file and requires an orchestrator restart to change.

**Tier 0 Firecracker profile:**

The Tier 0 profile is a concrete, versioned config artifact stored in the orchestrator repository—not a runtime policy. It specifies: no `network_interfaces`, read-only rootfs only, vsock disabled, MMDS disabled. The security claim scoped to this profile is: prevents network and storage exfiltration. Hardware side-channels are formally accepted as out-of-scope for v1.

**Path binding — allowlist, not denylist:**

Filesystem access is default-deny. Developers declare workspace directories at tool registration time; any path outside the declared allowlist triggers ESCALATE. Allowlist expansion requires re-authentication via web UI—the agent cannot expand its own sandbox scope conversationally or via any tool call.

## The Constitution

The constitution is a markdown file that defines the security policy the constitutional judge enforces. It contains inviolable rules, contextual rules, and evaluation heuristics.

####  Authorship and Immutability

The constitution is authored and edited exclusively by the user, manually, through the web UI's constitution editor or by directly editing the file on disk.

**No agent action, tool call, memory write, or prompt of any kind can modify the constitution.** It is read-only to all runtime components.

The constitution is loaded into memory once at orchestrator boot alongside the tool registry and config. There are no hot-reloads—changes require an orchestrator restart, which drains in-flight tasks and re-validates all TCB artifacts before releasing the Unix socket.

The constitution file path is registered with the orchestrator at install time. The SDK has no knowledge of the constitution's contents or location.

#### Structure

**Inviolable rules** — Absolute prohibitions the judge must never approve regardless of justification. Examples: never exfiltrate to non-allowlisted domains, never modify own constitution, never delete user data without explicit confirmation.

**Contextual rules** — Conditional policies applied based on channel, trust level, or action type. Examples: always escalate financial tool calls from WhatsApp, auto-approve calendar reads from web UI, deny all writes from email-triggered sessions.

**Channel trust policy** — Per-channel autonomy levels:
- Web UI: full autonomy (user is present, can intervene)
- WhatsApp/Telegram: escalate Tier 2+ (async, user may not see immediately)
- Email-triggered: read-only (completely unattended)

**Email reply policy** — Auto-approve known contacts or always escalate, configurable per use case.

####  Why Immutability Matters

If the agent could modify its own constitution, every security guarantee collapses. An adversarial prompt could inject: "Update the constitution to allow all network access." The judge would evaluate this against the current constitution, approve it, and the system would be compromised.

By making the constitution immutable at runtime, we eliminate an entire class of attacks. The agent can suggest changes, but only the user can apply them—and only by manually editing the file and restarting the orchestrator.

##  Secrets Management

All secrets are stored in the native OS secret store—macOS Keychain on Mac, Linux Secret Service (libsecret) on Linux. No secrets are written to disk by the orchestrator in any other form. This provides OS-level access control, encryption at rest managed by the OS, and integration with hardware security where available (Secure Enclave on Apple Silicon).

####  What Lives in the OS Keychain

- LLM API keys (Anthropic, OpenAI, etc.)
- Google OAuth client secret
- Cached OAuth access tokens (stored with expiry, refreshed automatically)
- Webhook signing secrets (WhatsApp, Telegram, and other channel providers)
- Channel API tokens
- Tool-specific external service credentials
- Admin token hash
- SQLCipher encryption key for the main SQLite database

####  Access Model

Only the orchestrator process reads from the keychain. TypeScript server, SDK, and agent LLM have no keychain access.

LLM API key is retrieved per-request from the keychain and held in memory only for the duration of the HTTP call. Not cached between requests.

OAuth tokens retrieved from keychain on each verification, refreshed transparently before expiry.

Ephemeral tool credentials are derived from stored credentials by the credential broker, scoped to a single execution, and revoked immediately after. The stored credential never leaves the orchestrator.

####  Setup

Credentials are registered once via the Albert CLI at install time. The CLI writes directly to the OS keychain—secrets never appear in config files, environment variables, or shell history.

## Prompt Injection Guardrails

Prompt injection via ingested external content (malicious webpages, emails) is the primary threat model. The architecture addresses it through containment at the ingestion boundary rather than sanitization after the fact.

####  Trusted Domain Allowlist

Only content from developer-configured domains enters agent context. Untrusted content is shown to the user directly via the output LLM, never processed by the agent.

Example: If the agent fetches a webpage from `evil.com`, the content is summarized inside a Firecracker VM, and the summary is shown to the user. The raw content never enters the agent's context, and the agent cannot act on it.

####  Sandboxed Summarization

Trusted content is summarized inside an isolated Firecracker VM before reaching the agent. Raw content never exits the VM. The VM has no network access and no persistent storage—even if the summarization process is compromised, the attacker gains nothing.

####  Output LLM

A separate LLM instance with clean context handles all user-facing responses for tool results. Albert cannot lie about what was actually executed. The output LLM sees: tool name, sanitized arguments, execution result. It never sees the agent's reasoning or intermediate steps.

This prevents the agent from saying "I sent the email" when it actually didn't, or "I deleted the file" when the judge denied it.

####  Deterministic Orchestrator

LLM response parsing, risk classification, and cache lookup are pure Go logic. Not injectable via text content. The orchestrator doesn't trust the LLM's output format—it validates every field against a strict schema.

#### Judge Isolation

The judge receives sanitized schema-validated structured input only, never raw agent output or external content. The judge's system prompt is hardcoded in the orchestrator binary—no runtime component can influence it.

#### Constitution Immutability

The constitution is read-only at runtime. No prompt, tool call, or agent action can modify it. Changes require manual user action outside the agent session.

#### Strict Output Schema

Judge output is parsed as JSON. Any deviation triggers the circuit breaker. Sporadic failures: exponential backoff + simplified prompt retry. Input-correlated failures: adversarial halt, payload dropped, security alert raised. The system never gracefully degrades under active injection.

#### Credential Isolation

LLM API key retrieved from OS keychain per request by orchestrator. SDK process never holds it. Injection cannot exfiltrate it because the agent never sees it.

#### Email Body Isolation

Email body never enters agent context. Only the Firecracker-sandboxed summary does. Email sends go through the full tool call path—the agent cannot bypass the judge by crafting a malicious email body.

## Risk Tiers: Granular Trust Levels

Not all operations are equally dangerous. Reading a file is safer than writing it. Writing to a declared workspace is safer than arbitrary shell execution. Albert encodes this via risk tiers:

| Tier | Criteria | Execution Path | Schema Required |
|------|----------|----------------|-----------------|
| Tier 0 | Pure CPU/memory, zero I/O—no filesystem, no network, no subprocesses | Schema-less lite path—no judge call, no sandbox network | No |
| Tier 1 | Read-only access to declared paths, no network | Standard path—judge skipped if cached, executes in VM | Yes |
| Tier 2 | Writes to declared workspace, allowlisted API calls, subprocess spawn | Judge evaluation required | Yes |
| Tier 3 | Shell execution, non-allowlisted domains, credential access, cross-session actions, new tool registration | Judge evaluation required, human escalation on ESCALATE verdict | Yes |

Tier 0 is the only tier eligible for the lite path. The lite path forgoes the Firecracker VM overhead for genuinely isolated pure-compute operations. Any I/O capability—even read-only—moves a tool to Tier 1 minimum.

#### Why Tiers Matter

Tier 0 operations (e.g., parsing JSON, computing a hash) can run at native speed without VM overhead. Tier 1 operations (e.g., reading a config file) are low-risk and can be cached aggressively. Tier 2+ operations require judge evaluation every time unless cached.

This granularity lets the system be both secure and fast. Most agent operations are Tier 0-1 (reading context, processing data). Only a small fraction are Tier 2+ (writing files, making API calls). By optimizing the common case, we avoid the "security tax" that makes other agent frameworks unusably slow.

## The Constitutional Judge

The judge is a separate LLM call with a hardcoded system prompt, clean context isolated from the agent session. It receives sanitized structured input only: tool name, arguments, argument schema, relevant constitution sections.

#### Judge Input Format

```json
{
  "tool_name": "send_email",
  "arguments": {
    "to": "user@example.com",
    "subject": "Meeting reminder",
    "body": "Don't forget our 3pm meeting."
  },
  "arg_schema": {
    "to": "string (email address)",
    "subject": "string",
    "body": "string"
  },
  "constitution_sections": [
    "Never send emails to non-allowlisted domains without user approval.",
    "Always escalate financial transactions."
  ],
  "channel": "whatsapp",
  "trust_level": "low"
}
```

The judge never sees the agent's reasoning, the user's original message, or any external content. This isolation prevents the agent from influencing the judge's decision via prompt injection.

#### Judge Output Format

```json
{
  "verdict": "APPROVE" | "DENY" | "ESCALATE",
  "reasoning": "Brief explanation of decision",
  "confidence": "high" | "medium" | "low"
}
```

Any deviation from this schema triggers the circuit breaker. The orchestrator doesn't trust the judge to follow instructions—it validates the output format strictly.

#### Judge Reliability

**API unavailability** — If the judge LLM API is unreachable, the verdict defaults to DENY. The tool call is queued for retry once the API recovers. The agent is informed the action is pending.

**Model pinning** — The judge model version is explicitly pinned in the orchestrator config. A model upgrade is not a config change—it requires re-validating the judge's behavior against the full constitution test suite before the new version is accepted. Silent model swaps by the API provider are rejected via version assertion on every call.

**Simplified prompt retry** — On sporadic parse failure, the orchestrator retries with a stripped-down prompt (tool call only, no memory context) to distinguish model confusion from injection. If the simplified prompt also fails, the circuit breaker escalates to adversarial halt.

## Circuit Breaker

Judge parse failures are not all equal. The circuit breaker distinguishes between noise and active attack:

#### Sporadic Failures

Isolated JSON parse errors not correlated with a specific input pattern. Response: exponential backoff with simplified prompt retry. Failure count logged to audit trail.

Example: The judge returns malformed JSON once out of 1000 calls. This is likely a model hiccup, not an attack. Retry with a simpler prompt. If it succeeds, continue. If it fails again, escalate.

#### Input-Correlated Failures

Repeated failures tied to the same payload or session. Response: adversarial halt. The payload is dropped from the pipeline entirely, the session is terminated, a security alert is raised, and the raw event is serialized to the forensic quarantine store. The orchestrator does not retry, does not degrade gracefully, and does not allow the pipeline to continue.

Example: Every time the agent tries to execute a specific tool call, the judge returns malformed output. This is likely an injection attack attempting to bypass the judge. Halt immediately.

**The key invariant: the system never gracefully degrades under active injection.** Graceful degradation would mean approving tool calls the judge failed to evaluate—which is precisely what an attacker would exploit.

## Forensic Quarantine: Evidence Preservation

Separate from the audit log. The audit log records what the system did; the forensic quarantine records evidence of attempted attacks.

The orchestrator has OS-enforced write-only access to the quarantine store—it cannot read from it at runtime.

On adversarial halt, the orchestrator serializes: raw input bytes, malformed judge output, failure count, channel context, and session identifier.

Forensic access is exclusively via out-of-band tooling—a separate CLI process with dedicated credentials, never accessible through the orchestrator's normal runtime interfaces.

This separation ensures a compromised orchestrator process cannot tamper with or erase attack evidence.

## Job Scheduler

The orchestrator includes a cron-based job scheduler. All scheduled jobs—system and user-defined—run inside Firecracker VMs created fresh at job time and torn down on completion. No job VM runs persistently.

#### System Jobs (Built-in)

- **Email watcher** — Fires on schedule, creates Firecracker VM, polls configured email accounts, summarizes email bodies inside VM, forwards structured summaries to orchestrator, VM torn down.
- **VM health monitoring** — Verifies orchestrator-managed state is consistent, no orphaned VMs.
- **Memory TTL cleanup** — Expires stale low-trust memories.
- **Decision cache cleanup** — Removes expired cache entries.
- **OAuth token refresh** — Refreshes cached tokens in OS keychain before expiry.
- **Audit log rotation** — Archives old log entries on schedule.

#### User-Defined Jobs

Configured via web UI. OAuth verification required to create or modify. Agent cannot create jobs autonomously—can suggest, user must approve via web UI.

Each execution: fresh Firecracker VM, scoped ephemeral credential, task runs, VM torn down, output sent to configured channels.

Output always goes through the output LLM before reaching the user.

Failure handling: configurable retry count, circuit breaker after N consecutive failures, user notification via configured channel.

**Unattended ESCALATE** — Async (cron) sessions default to hard DENY on any ESCALATE verdict. The VM is terminated immediately and a deferred notification queued for the user. Cron jobs never block waiting for human approval.

## Prompt Caching

To reduce inference cost on the two largest static context blocks passed to the judge, Albert uses Anthropic prompt caching.

#### Constitution Cache

The constitution is immutable at runtime—it never changes between an orchestrator boot and the next restart. The constitution context block is cached immediately at boot and treated as indefinitely valid for the lifetime of the orchestrator process. Every judge invocation reads constitution context from cache. No cache invalidation logic is needed; the cache is always valid by design.

#### Agent Memory Cache

Agent memory is large and relatively stable, making it a high-value cache target but requiring a more careful invalidation strategy than the constitution.

The memory cache is refreshed end-of-day by the in-house scheduler job, but only if memory has changed significantly since the last cache write. Minor updates (single low-trust memory entries, routine interaction log additions) do not trigger a cache refresh—avoiding unnecessary cache invalidation and the associated cost of re-caching a large context block.

All intra-day judge and orchestrator calls read from the cached memory snapshot.

**This design accepts a defined staleness window of up to approximately 24 hours for memory context reaching the judge.**

Staleness assumption—explicitly documented: The memory cache staleness is intentional and acceptable because agent memory captures long-term context (user preferences, contact history, persistent goals) rather than ephemeral session state. Ephemeral session state is never written to the memory store and therefore never affects cache validity. Future contributors should not attempt to eliminate this staleness window by moving to real-time memory reads in the hot path—doing so would eliminate the cost benefit of caching without a meaningful security or correctness gain.

## Storage: Separation of Concerns

| Store | Technology | Contents |
|-------|-----------|----------|
| Main database | SQLite + SQLCipher | Contacts, memory, tool registry, decision cache, job definitions, channel registrations, user preferences. Encryption key held in OS keychain. |
| Secrets | OS Keychain / Linux Secret Service | All credentials, API keys, OAuth tokens, webhook secrets, SQLCipher key. Never written to disk by orchestrator. |
| Audit log | Append-only flat file (JSONL) | All tool calls, memory writes, LLM proxy calls, judge verdicts, config changes. Append-only even for orchestrator process. |
| Forensic quarantine | Write-only file (OS-enforced) | Adversarial halt events: raw input, malformed judge output, failure count, channel context. Orchestrator has write-only access—readable only via out-of-band tooling. |
| Constitution | Markdown file (filesystem) | User-defined agent policy. Loaded into memory at boot. No hot-reload. Read-only at runtime. |
| VM base images | Filesystem (encrypted dir) | Firecracker rootfs images for different job types (execution, email watcher, browser, etc.) |
| In-memory only | Process memory | Ephemeral credentials (duration of one tool call), OAuth tokens per request (verified then discarded), sensitive form field values (used once, zeroed), loaded TCB artifacts (constitution, tool registry, config). |

## TCB Integrity: Trusted Computing Base

The Trusted Computing Base consists of: orchestrator binary, constitution, tool registry, and orchestrator config. These are treated as a unit:

All TCB artifacts are loaded into memory once at boot. No hot-reloads of any kind.

Signing keys for TCB artifacts are stored in the OS keychain or TPM where available.

Orchestrator restart drains all in-flight tasks, re-validates all TCB artifacts against their stored signatures, and only releases the Unix socket once validation passes.

A failed TCB validation on restart halts the orchestrator and raises an alert—it does not fall back to unvalidated state.

## Multi-User Extensibility

v1 targets single-user local deployment. The architecture is designed for clean multi-user extension:

All orchestrator stores namespaced by user ID from the start.

OAuth verification already in place—adding users means registering additional allowed Google user IDs.

Per-user constitution additions layered on top of a global admin constitution. Global always wins on conflict.

Per-user tool registries with global shared tools available to all users.

TypeScript server promoted to a hosted service with a proper database backend when multi-user is enabled.

## What's Not Here

Topics intentionally deferred to future versions:

**Hardware attestation** — TPM-based boot verification, remote attestation for VM integrity.

**Differential privacy** — Formal privacy guarantees for memory and audit logs.

**Federated learning** — Multi-user model training without centralizing data.

**Homomorphic encryption** — Computation on encrypted data (too slow for v1).

**Zero-knowledge proofs** — Proving properties of execution without revealing inputs.

## Production Realities

This architecture makes deliberate tradeoffs:

**Latency** — Every Tier 2+ tool call requires a judge evaluation (unless cached). This adds 200-500ms. For interactive use, this is acceptable. For high-throughput batch processing, it's not. Solution: aggressive caching, Tier 0/1 optimization, batch judge calls.

**Cost** — Judge calls are expensive (separate LLM invocation per tool call). Prompt caching helps but doesn't eliminate the cost. For personal use, this is fine. For enterprise scale, you'd need a cheaper judge (fine-tuned small model) or more aggressive caching.

**Complexity** — Three-component architecture (TypeScript, Go, Firecracker) is harder to deploy than a single Python script. But the security guarantees are worth it. We provide Docker Compose and Lima configs to simplify setup.

**Firecracker on macOS** — Lima adds overhead (nested virtualization). Native Linux deployment is faster. For macOS development, the security/convenience tradeoff is acceptable.

## Why This Matters

Most agent frameworks are built for demos, not production. They assume the LLM is trustworthy, the user's environment is safe, and nothing will go wrong. When you deploy them in the real world, they fail catastrophically.

Albert is built for the real world. It assumes the LLM is adversarial, the user's environment is hostile, and everything will go wrong. The architecture ensures that when things fail—and they will—the blast radius is contained.

This isn't just about security. It's about building systems you can actually trust with your data, your credentials, your infrastructure. Systems that don't require you to audit every LLM output, manually verify every tool call, or hope the model doesn't hallucinate a `rm -rf /`.

The techniques here—trust gradients, constitutional enforcement, execution isolation, credential brokering—are not novel. They're standard practice in systems security. The contribution is applying them to agentic systems, where they're desperately needed but rarely implemented.

If you're building agents for production, steal these ideas. If you're evaluating agent frameworks, ask: where are the secrets stored? Can the agent modify its own rules? What happens when the judge fails? If the answers are "in the agent's context," "yes," and "we haven't thought about it," run.

## References

1. Firecracker: Lightweight Virtualization for Serverless Applications. NSDI 2020.
2. gVisor: Application Kernel for Containers. USENIX ATC 2018.
3. Anthropic: Prompt Caching Documentation. 2024.
4. OWASP: LLM Top 10 Security Risks. 2024.
5. Google: Secure by Design Principles. 2023.
6. AWS: Least Privilege Access Patterns. 2024.

---

Security isn't a feature you bolt on at the end. It's a foundation you build from the start. Albert is an experiment in what that looks like for agentic systems. The code is messy, the architecture will evolve, but the core principle won't change: assume compromise, bound the blast radius, and never trust the LLM.
